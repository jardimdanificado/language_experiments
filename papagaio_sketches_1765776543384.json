{
  "papagaio_sketches": "{\"1765059298642\":{\"id\":\"1765059298642\",\"name\":\"novo\",\"input\":\"pattern {a} {b}\\n\\naaaa bbb aaaaaa ccc aaaaaaaa\\n\\n\\npattern {$$a,$b} {$b,$a}\\none,two\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\naaaaaaaaaa\",\"output\":\"\\n\\nbbbb bbb bbbbbb ccc bbbbbbbb\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nbbbbbbbbbb\",\"createdAt\":\"12/6/2025, 7:14:58 PM\"},\"1765181323552\":{\"id\":\"1765181323552\",\"name\":\"js\",\"input\":\"pattern {eval $block content{(}{)}} {$eval{$content;return \\\"\\\"}}\\npattern {const $name = $$conteudo;} {pattern {$name}{$conteudo}}\\npattern {papagaio.$$name = $$conteudo;} {$eval{papagaio.$name = \\\"$conteudo\\\";return \\\"\\\"}}\\npattern {papagaio.$name} {$eval{return papagaio.$name}}\\n\\nconst a = 555;\\neval(papagaio.b = {})\\npapagaio.b.c = 444;\\neval(return('a'))\\npapagaio.b.b = papagaio.b.c;\",\"output\":\"\\n\\n\\n\\n\\n\\n555\\n\\n555\",\"createdAt\":\"12/8/2025, 5:08:43 AM\"},\"1765288082309\":{\"id\":\"1765288082309\",\"name\":\"rap code generator\",\"input\":\"$eval{\\n\\n    function parseNumericString(s) {\\n        const str = s.trim();\\n        if (str === \\\"\\\") {\\n            return NaN;\\n        }\\n\\n        if (/^[+-]?\\\\d+(?:\\\\.\\\\d+)?[fF]$/.test(str)) {\\n            return Number(str.slice(0, -1));\\n        }\\n\\n        if (/^[+-]?(?:\\\\d*\\\\.\\\\d+|\\\\d+\\\\.\\\\d*)$/.test(str)) {\\n            return Number(str);\\n        }\\n\\n        if (/^[+-]?\\\\d+(?:\\\\.\\\\d+)?[eE][+-]?\\\\d+$/.test(str)) {\\n            return Number(str);\\n        }\\n\\n        if (/^[+-]?\\\\d+$/.test(str)) {\\n            return BigInt(str);\\n        }\\n\\n        if (/^[+-]?0[xX][0-9a-fA-F]+$/.test(str) ||\\n            /^[+-]?0[bB][01]+$/.test(str) ||\\n            /^[+-]?0[oO][0-7]+$/.test(str)) {\\n            return BigInt(str);\\n        }\\n\\n        return NaN;\\n    }\\n\\n    // isNaN doesnt work for BigInt's\\n    function isNumeric(x) {\\n        return (\\n            typeof x === \\\"number\\\" && !Number.isNaN(x) ||\\n            typeof x === \\\"bigint\\\"\\n        );\\n    }\\n\\n    papagaio.counter = 0;\\n    papagaio.funcs = [];\\n    papagaio.output = '#include \\\"urb.h\\\"\\\\n\\\\n';\\n    papagaio.assemble = (stuff) => {\\n        stuff = stuff.trim();\\n        let funcs = papagaio.funcs.join(\\\" \\\").replaceAll(\\\"URB_\\\", \\\"\\\").replaceAll(\\\"urb_\\\", \\\"\\\").split(\\\" \\\");\\n        let code = papagaio.content.replaceAll(\\\"\\\\n\\\", \\\" \\\").trim().split(\\\" \\\");\\n        let result = \\\"Value bytecode[] = [\\\";\\n        for (const token of code)\\n        {\\n            if (isNumeric(parseNumericString(token)))\\n            {\\n                result += \\\"(Value){.i = \\\" + parseNumericString(token) + \\\"},\\\\n\\\"\\n                continue;\\n            }\\n            else if (token[0] == '@')\\n            {\\n                result += \\\"(Value){.u = \\\" + \\\"(\\\" + \\\"INT_MAX - \\\" + token.slice(1) + \\\" )\\\" + \\\"},\\\\n\\\"\\n            }\\n            else\\n            {\\n                for (const funcname of funcs)\\n                {\\n                    if (funcname == token)\\n                    {\\n                        result += \\\"(Value){.u = (INT_MIN + OP_CODES_OFFSET + \\\" + funcs.indexOf(token) + \\\")},\\\\n\\\"\\n                        break;\\n                    }\\n                }\\n                continue;\\n            }\\n        }\\n        result += \\\"]\\\";\\n        result = result.replaceAll(\\\",\\\\n]\\\", \\\"];\\\");\\n        return result;\\n    }\\n\\n    papagaio.exit = () =>{\\n        papagaio.output += \\\"\\\\nint main(int argc, char* argv[]){\\\\n\\\";\\n        papagaio.output += papagaio.assemble(papagaio.content);\\n        papagaio.output += \\\"List *context = urb_new(papagaio.funcs.length);\\\\n\\\";\\n        for (const name of papagaio.funcs)\\n        {\\n            papagaio.output += \\\"urb_push(context, (Value){.p = \\\" + name + \\\"});\\\\n\\\";\\n        }\\n        papagaio.output += \\\"urb_interpret(context, compiled_bytecode, NULL);\\\\n\\\";\\n        papagaio.output += \\\"urb_free(context);\\\\n\\\";\\n        papagaio.output += \\\"\\\\n}\\\";\\n        papagaio.content = papagaio.output;\\n        return \\\"\\\";\\n    }\\n    return \\\"\\\"\\n}\\n\\n$pattern{C $block c_code{}{}}\\n{\\n    $eval{\\n        papagaio.output = papagaio.output + \\\"\\\\n\\\\n\\\" + `$c_code` + \\\"\\\\n\\\";\\n        return \\\"\\\";\\n    }\\n    \\n    $pattern{void $funcname(List * stack) $block conteudo{} {}}\\n    {\\n        $eval{\\n            papagaio.funcs.push(\\\"$funcname\\\");\\n            return papagaio.match;\\n        }\\n    }\\n}\\n\\nC {\\n    void URB_interpret(List *stack)\\n    {\\n        List *exec = urb_pop(stack).p;\\n        List *mem = urb_pop(stack).p;\\n        List *_stack = urb_pop(stack).p;\\n        urb_interpret(exec, mem, _stack);\\n    }\\n\\n    void URB_push(List* stack)\\n    {\\n        List* list = urb_pop(stack).p;\\n        Value value = urb_pop(stack);\\n        urb_push(list, value);\\n    }\\n\\n    void URB_stack(List *stack)\\n    {\\n        urb_push(stack, (Value){.p = stack});\\n    }\\n\\n    void URB_dup(List *stack)\\n    {\\n        urb_push(stack, stack->data[stack->size - 1]);\\n    }\\n\\n    void URB_over(List *stack)\\n    {\\n        Value a = urb_pop(stack);\\n        Value b = urb_pop(stack);\\n        urb_push(stack, b);\\n        urb_push(stack, a);\\n        urb_push(stack, b);\\n    }\\n\\n    void URB_rot(List *stack)\\n    {\\n        Value a = urb_pop(stack);\\n        Value b = urb_pop(stack);\\n        Value c = urb_pop(stack);\\n        urb_push(stack, b);\\n        urb_push(stack, a);\\n        urb_push(stack, c);\\n    }\\n\\n    void URB_drop(List *stack)\\n    {\\n        urb_pop(stack);\\n    }\\n}\\n\\n785 stack push\",\"output\":\"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n// interpret\\n// URB_interpret\\n#define OP_URB_interpret (INT_MIN + OP_CODES_OFFSET + 0)\\nvoid URB_interpret(List* stack) {\\n    List* exec = urb_pop(stack).p;\\n    List* mem = urb_pop(stack).p;\\n    List* _stack = urb_pop(stack).p;\\n    urb_interpret(exec, mem, _stack);\\n}\\n\\n\\n// URB_stack\\n#define OP_URB_stack (INT_MIN + OP_CODES_OFFSET + 1)\\nvoid URB_stack(List* stack) {\\n    urb_push(stack, (Value){.p = stack});\\n}\\n\\n\\n// URB_dup\\n#define OP_URB_dup (INT_MIN + OP_CODES_OFFSET + 2)\\nvoid URB_dup(List* stack) {\\n    urb_push(stack, stack->data[stack->size - 1]);\\n}\\n\\n\\n// URB_over\\n#define OP_URB_over (INT_MIN + OP_CODES_OFFSET + 3)\\nvoid URB_over(List* stack) {\\n    Value a = urb_pop(stack);\\n    Value b = urb_pop(stack);\\n    urb_push(stack, b);\\n    urb_push(stack, a);\\n    urb_push(stack, b);\\n}\\n\\n\\n// URB_rot\\n#define OP_URB_rot (INT_MIN + OP_CODES_OFFSET + 4)\\nvoid URB_rot(List* stack) {\\n    Value a = urb_pop(stack);\\n    Value b = urb_pop(stack);\\n    Value c = urb_pop(stack);\\n    urb_push(stack, b);\\n    urb_push(stack, a);\\n    urb_push(stack, c);\\n}\\n\\n\\n// URB_drop\\n#define OP_URB_drop (INT_MIN + OP_CODES_OFFSET + 5)\\nvoid URB_drop(List* stack) {\\n    urb_pop(stack);\\n}\\n\\n\\n\\n#define INIT_URB(context)\\\\\\nurb_push(context, (Value){.p = URB_interpret});\\\\\\nurb_push(context, (Value){.p = URB_stack});\\\\\\nurb_push(context, (Value){.p = URB_dup});\\\\\\nurb_push(context, (Value){.p = URB_over});\\\\\\nurb_push(context, (Value){.p = URB_rot});\\\\\\nurb_push(context, (Value){.p = URB_drop});\\\\\\n0;\",\"createdAt\":\"12/9/2025, 10:48:02 AM\"},\"1765295974058\":{\"id\":\"1765295974058\",\"name\":\"delimiters\",\"input\":\"pattern {eval $block str{(}{)}} {$eval{$str; return \\\"\\\"}}\\neval(console.log(papagaio);papagaio.symbols.open = \\\"[\\\";papagaio.symbols.close = \\\"]\\\";)\\npattern [a] [b]\\naaaaaaaaaaaaaaaaaaa\",\"output\":\"\\n\\n\\nbbbbbbbbbbbbbbbbbbb\",\"createdAt\":\"12/9/2025, 12:59:34 PM\"},\"1765304603121\":{\"id\":\"1765304603121\",\"name\":\"teste\",\"input\":\"pattern {eval $block str{(}{)}} {o match é $eval{$str; return \\\"\\\"}}\\neval(return papagaio.match)\\n\\npattern {$$$x world} {<$x>}\\nworld\",\"output\":\"\\no match é eval(return papagaio.match)\",\"createdAt\":\"12/9/2025, 3:23:23 PM\"},\"1765307172823\":{\"id\":\"1765307172823\",\"name\":\"multichar\",\"input\":\"pattern {eval $block str{(}{)}} {$eval{$str; return \\\"\\\"}}\\neval(papagaio.symbols.open = 'ab';papagaio.symbols.close = 'bc';)\\n\\npattern ab greet $name bc ab Hello, $name! bc\\n\\ngreet World\\ngreet JavaScript\",\"output\":\"\\n\\n\\n\\n\\nHello, World!\\nHello, JavaScript!\",\"createdAt\":\"12/9/2025, 4:06:12 PM\"},\"1765316508188\":{\"id\":\"1765316508188\",\"name\":\"rap assembler\",\"input\":\"pattern{eval $block code{(}{)}}{$eval{$code;return \\\"\\\"}}\\neval(\\nglobalThis.toBin8 = function (n) {\\n  return (n & 0xFF).toString(2).padStart(8, \\\"0\\\");\\n}\\n\\nglobalThis.toBin16 = function (n) {\\n  return (n & 0xFFFF).toString(2).padStart(16, \\\"0\\\");\\n}\\n\\nglobalThis.toBin64 = function (n) {\\n  return BigInt(n).toString(2).padStart(64, \\\"0\\\");\\n}\\n\\nglobalThis.printBin32 = function (n) {\\n  const buf = new ArrayBuffer(4);\\n  const u32 = new DataView(buf);\\n  const u8  = new Uint8Array(buf);\\n\\n  u32.setUint32(0, n);\\n\\n  let out = \\\"\\\";\\n  for (const b of u8) out += b.toString(2).padStart(8, \\\"0\\\");\\n  console.log(out);\\n}\\n)\\n\\neval(return printBin32(120))\\n\\n\",\"createdAt\":\"12/9/2025, 6:41:48 PM\"},\"1765328449662\":{\"id\":\"1765328449662\",\"name\":\"teste\",\"input\":\"pattern {$block content{trate como javascript}{até aqui}} {funcionou $content}\\ntrate como javascript aadsdasdasdsda até aqui\",\"createdAt\":\"12/9/2025, 10:00:49 PM\"},\"1765591860016\":{\"id\":\"1765591860016\",\"name\":\"c with classes\",\"input\":\"$pattern{object $name = $block stuff{}{};}\\n{\\n    object $name;\\n}\\n\\n$pattern{object $name $block stuff{=}{;}}\\n{\\n    object $name;\\n}\\n\\n$pattern{object $name;} {\\n    $eval{\\n        if (!papagaio.objects)\\n        {\\n            papagaio.objects = {};\\n        }\\n        papagaio.objects[\\\"$name\\\"] = {};\\n        return \\\"\\\";\\n    }\\n}\\n\\n$pattern{$name.$property} {$eval {\\n    if (papagaio.objects.hasOwnProperty(\\\"$name\\\"))\\n    {\\n        if (!papagaio.objects[\\\"$name\\\"].hasOwnProperty(\\\"$property\\\"))\\n        {\\n            papagaio.objects[\\\"$name\\\"][\\\"$property\\\"] = {};\\n        }\\n    }\\n    return \\\"$name.$property\\\";\\n}}\\n\\nobject abc = {};\\n\\n#include <stdio.h>\\nint main() {\\n    abc.d = 44;\\n    printf(\\\"Hello, World!\\\");\\n    return 0;\\n}\\n\",\"createdAt\":\"12/12/2025, 11:11:00 PM\"}}",
  "papagaio_current_sketch": "1765288082309",
  "papagaio_config": null
}