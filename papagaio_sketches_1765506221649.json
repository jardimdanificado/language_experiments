{
  "papagaio_sketches": "{\"1765058302461\":{\"id\":\"1765058302461\",\"name\":\"stdlib\",\"input\":\"// remove comments\\n$pattern {// $comment $regex newline{[^\\\\n]*}} {}\\n\\n// cleanup\\n$pattern {$regex spaces{\\\\s\\\\s}}{ }\",\"output\":\"\",\"createdAt\":\"12/6/2025, 6:58:22 PM\"},\"1765059298642\":{\"id\":\"1765059298642\",\"name\":\"novo\",\"input\":\"$pattern {a} {b}\\n\\naaaa bbb aaaaaa ccc aaaaaaaa\\n\\n\\n$pattern {$a,$b} {$b,$a}\\n\\none,two\\n\\n\\naaaaaaaaaa\",\"output\":\"\\n\\nbbbb bbb bbbbbb ccc bbbbbbbb\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nbbbbbbbbbb\",\"createdAt\":\"12/6/2025, 7:14:58 PM\"},\"1765288082309\":{\"id\":\"1765288082309\",\"name\":\"rap code generator\",\"input\":\"$eval{papagaio.counter = 0;return \\\"\\\"}\\n$eval{papagaio.inits = [];return \\\"\\\"}\\n\\n\\n$pattern {void $funcname (List* stack) $block conteudo {}{}} \\n{\\n// $funcname\\n#define OP_$funcname (INT_MIN + OP_CODES_OFFSET + $eval{return (papagaio.counter++)})\\nvoid $funcname(List* stack) {$conteudo}\\n$eval{papagaio.inits.push(\\\"$funcname\\\");return \\\"\\\"}\\n}\\n\\n$pattern {_INIT} {$eval{\\nlet content = \\\"#define INIT_URB(context)\\\\\\\\\\\\n\\\";\\nfor (const name of papagaio.inits) \\n{\\ncontent += \\\"urb_push(context, (Value){.p = \\\" + name + \\\"});\\\\\\\\\\\\n\\\";\\n}\\ncontent += \\\"0;\\\"\\nreturn content;\\n}}\\n\\n\\n// interpret\\nvoid URB_interpret(List* stack)\\n{\\n    List* exec = urb_pop(stack).p;\\n    List* mem = urb_pop(stack).p;\\n    List* _stack = urb_pop(stack).p;\\n    urb_interpret(exec, mem, _stack);\\n}\\n\\nvoid URB_stack(List* stack)\\n{\\n    urb_push(stack, (Value){.p = stack});\\n}\\n\\nvoid URB_dup(List* stack)\\n{\\n    urb_push(stack, stack->data[stack->size - 1]);\\n}\\n\\nvoid URB_over(List* stack)\\n{\\n    Value a = urb_pop(stack);\\n    Value b = urb_pop(stack);\\n    urb_push(stack, b);\\n    urb_push(stack, a);\\n    urb_push(stack, b);\\n}\\n\\nvoid URB_rot(List* stack)\\n{\\n    Value a = urb_pop(stack);\\n    Value b = urb_pop(stack);\\n    Value c = urb_pop(stack);\\n    urb_push(stack, b);\\n    urb_push(stack, a);\\n    urb_push(stack, c);\\n}\\n\\nvoid URB_drop(List* stack)\\n{\\n    urb_pop(stack);\\n}\\n\\n\\n_INIT\",\"output\":\"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n// interpret\\n// URB_interpret\\n#define OP_URB_interpret (INT_MIN + OP_CODES_OFFSET + 0)\\nvoid URB_interpret(List* stack) {\\n    List* exec = urb_pop(stack).p;\\n    List* mem = urb_pop(stack).p;\\n    List* _stack = urb_pop(stack).p;\\n    urb_interpret(exec, mem, _stack);\\n}\\n\\n\\n// URB_stack\\n#define OP_URB_stack (INT_MIN + OP_CODES_OFFSET + 1)\\nvoid URB_stack(List* stack) {\\n    urb_push(stack, (Value){.p = stack});\\n}\\n\\n\\n// URB_dup\\n#define OP_URB_dup (INT_MIN + OP_CODES_OFFSET + 2)\\nvoid URB_dup(List* stack) {\\n    urb_push(stack, stack->data[stack->size - 1]);\\n}\\n\\n\\n// URB_over\\n#define OP_URB_over (INT_MIN + OP_CODES_OFFSET + 3)\\nvoid URB_over(List* stack) {\\n    Value a = urb_pop(stack);\\n    Value b = urb_pop(stack);\\n    urb_push(stack, b);\\n    urb_push(stack, a);\\n    urb_push(stack, b);\\n}\\n\\n\\n// URB_rot\\n#define OP_URB_rot (INT_MIN + OP_CODES_OFFSET + 4)\\nvoid URB_rot(List* stack) {\\n    Value a = urb_pop(stack);\\n    Value b = urb_pop(stack);\\n    Value c = urb_pop(stack);\\n    urb_push(stack, b);\\n    urb_push(stack, a);\\n    urb_push(stack, c);\\n}\\n\\n\\n// URB_drop\\n#define OP_URB_drop (INT_MIN + OP_CODES_OFFSET + 5)\\nvoid URB_drop(List* stack) {\\n    urb_pop(stack);\\n}\\n\\n\\n\\n#define INIT_URB(context)\\\\\\nurb_push(context, (Value){.p = URB_interpret});\\\\\\nurb_push(context, (Value){.p = URB_stack});\\\\\\nurb_push(context, (Value){.p = URB_dup});\\\\\\nurb_push(context, (Value){.p = URB_over});\\\\\\nurb_push(context, (Value){.p = URB_rot});\\\\\\nurb_push(context, (Value){.p = URB_drop});\\\\\\n0;\",\"createdAt\":\"12/9/2025, 10:48:02 AM\"},\"1765304603121\":{\"id\":\"1765304603121\",\"name\":\"optional\",\"input\":\"$pattern {aaaaa $x? world} {<$x>}\\naaaaa  world\",\"output\":\"\\no match é eval(return papagaio.match)\",\"createdAt\":\"12/9/2025, 3:23:23 PM\"},\"1765307172823\":{\"id\":\"1765307172823\",\"name\":\"multichar\",\"input\":\"// custom delimtiers test\\n@pattern ab greet @name bc ab Hello, @name! bc\\n\\ngreet World\\ngreet JavaScript\",\"output\":\"\\n\\n\\n\\n\\nHello, World!\\nHello, JavaScript!\",\"createdAt\":\"12/9/2025, 4:06:12 PM\"},\"1765411870105\":{\"id\":\"1765411870105\",\"name\":\"regex\",\"input\":\"// apaga todos os comentarios\\n$pattern {// $comment $regex newline{[^\\\\n]*}} {}\\n\\n// Capturar apenas números\\n$pattern {numero: $regex num{[0-9]+}} {O número é $num}\\nnumero: 42\\n// Resultado: O número é 42\\n\\n// Capturar email\\n$pattern {email: $regex mail{[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\\\.[a-zA-Z]{2,}}} {Email: $mail}\\nemail: teste@exemplo.com\\n// Resultado: Email: teste@exemplo.com\\n\\n// Capturar palavras específicas\\n$pattern {status: $regex estado{(ativo|inativo|pendente)}} {Status: $estado}\\nstatus: ativo\\n// Resultado: Status: ativo\\n\\n// Capturar hexadecimal\\n$pattern {cor: $regex hex{#[0-9A-Fa-f]{6}}} {Cor capturada: $hex}\\ncor: #FF5733\\n// Resultado: Cor capturada: #FF5733\",\"createdAt\":\"12/10/2025, 9:11:10 PM\"},\"1765468252045\":{\"id\":\"1765468252045\",\"name\":\"wasm\",\"input\":\"// generic ts-like to wasm compiler\\n\\n$pattern {// $comment $regex newline{[^\\\\n]*}} {}\\n$pattern {$regex spaces{\\\\s\\\\s}}{ }\\n\\n$eval{\\n    papagaio.exit = function()\\n    {\\n        papagaio.content = \\\"(module\\\\n\\\" + papagaio.content + \\\"\\\\n)\\\";\\n        papagaio.exit = null;\\n    };\\n    return \\\"\\\"\\n}\\n\\n$pattern {export function $name $block params{(}{)}:$rets $block content{}{}} {\\n    $pattern {parametrize}\\n    {\\n        $eval {\\n            let str = \\\"$params\\\".replace(\\\"(\\\", \\\"\\\").replace(\\\")\\\", \\\"\\\");\\n            let params = str.split(\\\",\\\").map(p => p.trim()).filter(p => p);\\n            let new_stuff = \\\"\\\";\\n            for (const param of params) {\\n                if (!param.includes(\\\":\\\")) continue; // Pula se não tem ':'\\n                const [name, type] = param.split(\\\":\\\");\\n                if (name && type) { // Verifica se ambos existem\\n                    new_stuff += ` (param $${name.trim()} ${type.trim()}) `;\\n                }\\n            }\\n            return new_stuff;\\n        }\\n    }\\n\\n    (func (export \\\"$name\\\") parametrize (result $rets)\\n        $content\\n    )\\n}\\n\\n$pattern {function $name $block params{(}{)}:$rets $block content{}{}} {\\n    $pattern {parametrize}\\n    {\\n        $eval {\\n            let str = \\\"$params\\\".replace(\\\"(\\\", \\\"\\\").replace(\\\")\\\", \\\"\\\");\\n            let params = str.split(\\\",\\\").map(p => p.trim()).filter(p => p);\\n            let new_stuff = \\\"\\\";\\n            for (const param of params) {\\n                if (!param.includes(\\\":\\\")) continue; // Pula se não tem ':'\\n                const [name, type] = param.split(\\\":\\\");\\n                if (name && type) { // Verifica se ambos existem\\n                    new_stuff += ` (param $${name.trim()} ${type.trim()}) `;\\n                }\\n            }\\n            return new_stuff;\\n        }\\n    }\\n\\n    (func $$name parametrize (result $rets)\\n        $content\\n    )\\n}\\n\\nfunction name(a:i32, b:i32):i64 i64\\n{\\n    contentnans\\n}\\n\\nexport function funcao_exportada(a:f32, b:f32, c:f32):i64 i64 i64 i64\\n{\\n    fução expoortada1\\n}\\n\",\"createdAt\":\"12/11/2025, 12:50:52 PM\"},\"1765499397266\":{\"id\":\"1765499397266\",\"name\":\"scopes\",\"input\":\"$pattern {a} {\\n   $pattern{b}{c}\\n   $pattern{d}{\\n      bbbbb\\n}\\nd\\n}\\n\\na\",\"createdAt\":\"12/11/2025, 9:29:57 PM\"}}",
  "papagaio_current_sketch": "1765468252045",
  "papagaio_config": "{\"sigil\":\"$\",\"open\":\"{\",\"close\":\"}\",\"local\":\"local\",\"global\":\"global\",\"eval\":\"eval\",\"block\":\"block\",\"regex\":\"regex\"}"
}