{
  "papagaio_sketches": "{\"1765058302461\":{\"id\":\"1765058302461\",\"name\":\"Default\",\"input\":\"pattern {$regex year {[0-9]{4}}-$regex month {[0-9]{2}}} {Month $month in $year}\\n2024-03\",\"output\":\"\",\"createdAt\":\"12/6/2025, 6:58:22 PM\"},\"1765058440821\":{\"id\":\"1765058440821\",\"name\":\"dasdasdasddasdasdas\",\"input\":\"dsadadasdasdasdaaaaaaaaaaaaa\",\"output\":\"\",\"createdAt\":\"12/6/2025, 7:00:40 PM\"},\"1765059298642\":{\"id\":\"1765059298642\",\"name\":\"novo\",\"input\":\"pattern {a} {b}\\n\\naaaa bbb aaaaaa ccc aaaaaaaa\\n\\n\\npattern {$$a,$b} {$b,$a}\\none,two\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\naaaaaaaaaa\",\"output\":\"\\n\\nbbbb bbb bbbbbb ccc bbbbbbbb\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nbbbbbbbbbb\",\"createdAt\":\"12/6/2025, 7:14:58 PM\"},\"1765181323552\":{\"id\":\"1765181323552\",\"name\":\"js\",\"input\":\"pattern {eval $block content{(}{)}} {$eval{$content;return \\\"\\\"}}\\npattern {const $name = $$conteudo;} {pattern {$name}{$conteudo}}\\npattern {papagaio.$$name = $$conteudo;} {$eval{papagaio.$name = \\\"$conteudo\\\";return \\\"\\\"}}\\npattern {papagaio.$name} {$eval{return papagaio.$name}}\\n\\nconst a = 555;\\neval(papagaio.b = {})\\npapagaio.b.c = 444;\\neval(return('a'))\\npapagaio.b.b = papagaio.b.c;\",\"output\":\"\\n\\n\\n\\n\\n\\n555\\n\\n555\",\"createdAt\":\"12/8/2025, 5:08:43 AM\"},\"1765288082309\":{\"id\":\"1765288082309\",\"name\":\"rap code generator\",\"input\":\"pattern {eval $block str{(}{)}} {$eval{$str; return \\\"\\\"}}\\neval(papagaio.counter = 0)\\neval(papagaio.inits = [])\\n\\n\\npattern {void $funcname (List* stack) $block conteudo {}{}} \\n{\\n// $funcname\\n#define OP_$funcname (INT_MIN + OP_CODES_OFFSET + $eval{return (papagaio.counter++)})\\nvoid $funcname(List* stack) {$conteudo}\\n$eval{papagaio.inits.push(\\\"$funcname\\\");return \\\"\\\"}\\n}\\n\\npattern {_INIT} {$eval{\\nlet content = \\\"#define INIT_URB(context)\\\\\\\\\\\\n\\\";\\nfor (const name of papagaio.inits) \\n{\\ncontent += \\\"urb_push(context, (Value){.p = \\\" + name + \\\"});\\\\\\\\\\\\n\\\";\\n}\\ncontent += \\\"0;\\\"\\nreturn content;\\n}}\\n\\n\\n// interpret\\nvoid URB_interpret(List* stack)\\n{\\n    List* exec = urb_pop(stack).p;\\n    List* mem = urb_pop(stack).p;\\n    List* _stack = urb_pop(stack).p;\\n    urb_interpret(exec, mem, _stack);\\n}\\n\\nvoid URB_stack(List* stack)\\n{\\n    urb_push(stack, (Value){.p = stack});\\n}\\n\\nvoid URB_dup(List* stack)\\n{\\n    urb_push(stack, stack->data[stack->size - 1]);\\n}\\n\\nvoid URB_over(List* stack)\\n{\\n    Value a = urb_pop(stack);\\n    Value b = urb_pop(stack);\\n    urb_push(stack, b);\\n    urb_push(stack, a);\\n    urb_push(stack, b);\\n}\\n\\nvoid URB_rot(List* stack)\\n{\\n    Value a = urb_pop(stack);\\n    Value b = urb_pop(stack);\\n    Value c = urb_pop(stack);\\n    urb_push(stack, b);\\n    urb_push(stack, a);\\n    urb_push(stack, c);\\n}\\n\\nvoid URB_drop(List* stack)\\n{\\n    urb_pop(stack);\\n}\\n\\n\\n_INIT\",\"output\":\"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n// interpret\\n// URB_interpret\\n#define OP_URB_interpret (INT_MIN + OP_CODES_OFFSET + 0)\\nvoid URB_interpret(List* stack) {\\n    List* exec = urb_pop(stack).p;\\n    List* mem = urb_pop(stack).p;\\n    List* _stack = urb_pop(stack).p;\\n    urb_interpret(exec, mem, _stack);\\n}\\n\\n\\n// URB_stack\\n#define OP_URB_stack (INT_MIN + OP_CODES_OFFSET + 1)\\nvoid URB_stack(List* stack) {\\n    urb_push(stack, (Value){.p = stack});\\n}\\n\\n\\n// URB_dup\\n#define OP_URB_dup (INT_MIN + OP_CODES_OFFSET + 2)\\nvoid URB_dup(List* stack) {\\n    urb_push(stack, stack->data[stack->size - 1]);\\n}\\n\\n\\n// URB_over\\n#define OP_URB_over (INT_MIN + OP_CODES_OFFSET + 3)\\nvoid URB_over(List* stack) {\\n    Value a = urb_pop(stack);\\n    Value b = urb_pop(stack);\\n    urb_push(stack, b);\\n    urb_push(stack, a);\\n    urb_push(stack, b);\\n}\\n\\n\\n// URB_rot\\n#define OP_URB_rot (INT_MIN + OP_CODES_OFFSET + 4)\\nvoid URB_rot(List* stack) {\\n    Value a = urb_pop(stack);\\n    Value b = urb_pop(stack);\\n    Value c = urb_pop(stack);\\n    urb_push(stack, b);\\n    urb_push(stack, a);\\n    urb_push(stack, c);\\n}\\n\\n\\n// URB_drop\\n#define OP_URB_drop (INT_MIN + OP_CODES_OFFSET + 5)\\nvoid URB_drop(List* stack) {\\n    urb_pop(stack);\\n}\\n\\n\\n\\n#define INIT_URB(context)\\\\\\nurb_push(context, (Value){.p = URB_interpret});\\\\\\nurb_push(context, (Value){.p = URB_stack});\\\\\\nurb_push(context, (Value){.p = URB_dup});\\\\\\nurb_push(context, (Value){.p = URB_over});\\\\\\nurb_push(context, (Value){.p = URB_rot});\\\\\\nurb_push(context, (Value){.p = URB_drop});\\\\\\n0;\",\"createdAt\":\"12/9/2025, 10:48:02 AM\"},\"1765295974058\":{\"id\":\"1765295974058\",\"name\":\"delimiters\",\"input\":\"pattern {eval $block str{(}{)}} {$eval{$str; return \\\"\\\"}}\\neval(console.log(papagaio);papagaio.symbols.open = \\\"[\\\";papagaio.symbols.close = \\\"]\\\";)\\npattern [a] [b]\\naaaaaaaaaaaaaaaaaaa\",\"output\":\"\\n\\n\\nbbbbbbbbbbbbbbbbbbb\",\"createdAt\":\"12/9/2025, 12:59:34 PM\"},\"1765304603121\":{\"id\":\"1765304603121\",\"name\":\"teste\",\"input\":\"pattern {aaaaa $x? world} {<$x>}\\naaaaa  world\",\"output\":\"\\no match é eval(return papagaio.match)\",\"createdAt\":\"12/9/2025, 3:23:23 PM\"},\"1765307172823\":{\"id\":\"1765307172823\",\"name\":\"multichar\",\"input\":\"pattern {eval $block str{(}{)}} {$eval{$str; return \\\"\\\"}}\\neval(papagaio.symbols.open = 'ab';papagaio.symbols.close = 'bc';)\\n\\npattern ab greet $name bc ab Hello, $name! bc\\n\\ngreet World\\ngreet JavaScript\",\"output\":\"\\n\\n\\n\\n\\nHello, World!\\nHello, JavaScript!\",\"createdAt\":\"12/9/2025, 4:06:12 PM\"},\"1765316508188\":{\"id\":\"1765316508188\",\"name\":\"rap assembler\",\"input\":\"pattern{eval $block code{(}{)}}{$eval{$code;return \\\"\\\"}}\\neval(\\nglobalThis.toBin8 = function (n) {\\n  return (n & 0xFF).toString(2).padStart(8, \\\"0\\\");\\n}\\n\\nglobalThis.toBin16 = function (n) {\\n  return (n & 0xFFFF).toString(2).padStart(16, \\\"0\\\");\\n}\\n\\nglobalThis.toBin64 = function (n) {\\n  return BigInt(n).toString(2).padStart(64, \\\"0\\\");\\n}\\n\\nglobalThis.printBin32 = function (n) {\\n  const buf = new ArrayBuffer(4);\\n  const u32 = new DataView(buf);\\n  const u8  = new Uint8Array(buf);\\n\\n  u32.setUint32(0, n);\\n\\n  let out = \\\"\\\";\\n  for (const b of u8) out += b.toString(2).padStart(8, \\\"0\\\");\\n  console.log(out);\\n}\\n)\\n\\neval(return printBin32(120))\\n\\n\",\"createdAt\":\"12/9/2025, 6:41:48 PM\"},\"1765411870105\":{\"id\":\"1765411870105\",\"name\":\"regex\",\"input\":\"// apaga todos os comentarios\\npattern {// $comment $regex newline{[^\\\\n]*}} {}\\n\\n// Capturar apenas números\\npattern {numero: $regex num{[0-9]+}} {O número é $num}\\nnumero: 42\\n// Resultado: O número é 42\\n\\n// Capturar email\\npattern {email: $regex mail{[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\\\.[a-zA-Z]{2,}}} {Email: $mail}\\nemail: teste@exemplo.com\\n// Resultado: Email: teste@exemplo.com\\n\\n// Capturar palavras específicas\\npattern {status: $regex estado{(ativo|inativo|pendente)}} {Status: $estado}\\nstatus: ativo\\n// Resultado: Status: ativo\\n\\n// Capturar hexadecimal\\npattern {cor: $regex hex{#[0-9A-Fa-f]{6}}} {Cor capturada: $hex}\\ncor: #FF5733\\n// Resultado: Cor capturada: #FF5733\",\"createdAt\":\"12/10/2025, 9:11:10 PM\"}}",
  "papagaio_current_sketch": "1765411870105"
}