{
  "papagaio_sketches": "{\"1765058302461\":{\"id\":\"1765058302461\",\"name\":\"stdlib\",\"input\":\"// remove comments\\n$pattern {// $comment $regex newline{[^\\\\n]*}} {}\\n\\n// cleanup\\n$pattern {$regex spaces{\\\\s\\\\s}}{ }\",\"output\":\"\",\"createdAt\":\"12/6/2025, 6:58:22 PM\"},\"1765059298642\":{\"id\":\"1765059298642\",\"name\":\"novo\",\"input\":\"$pattern {a} {b}\\n\\naaaa bbb aaaaaa ccc aaaaaaaa\\n\\n\\n$pattern {$a,$b} {$b,$a}\\n\\none,two\\n\\n\\naaaaaaaaaa\",\"output\":\"\\n\\nbbbb bbb bbbbbb ccc bbbbbbbb\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nbbbbbbbbbb\",\"createdAt\":\"12/6/2025, 7:14:58 PM\"},\"1765288082309\":{\"id\":\"1765288082309\",\"name\":\"rap code generator\",\"input\":\"#include \\\"urb.h\\\"\\n\\n \\n#include \\\"urb.h\\\"\\n\\nvoid test_func(List* stack)\\n{\\n    Value v = urb_pop(stack);\\n    printf(\\\"value = %ld\\\\n\\\", v.i);\\n}\\n#include \\\"urb.h\\\"\\n\\nvoid URB_add(List* stack)\\n{\\n    Int a = urb_pop(stack).i;\\n    Int b = urb_pop(stack).i;\\n    urb_push(stack, (Value){.i = a + b});\\n}\\n\\nvoid URB_sub(List* stack)\\n{\\n    Int a = urb_pop(stack).i;\\n    Int b = urb_pop(stack).i;\\n    urb_push(stack, (Value){.i = a - b});\\n}\\n\\nvoid URB_mul(List* stack)\\n{\\n    Int a = urb_pop(stack).i;\\n    Int b = urb_pop(stack).i;\\n    urb_push(stack, (Value){.i = a * b});\\n}\\n\\nvoid URB_div(List* stack)\\n{\\n    Int a = urb_pop(stack).i;\\n    Int b = urb_pop(stack).i;\\n    if (a == 0) {\\n        urb_push(stack, (Value){.i = 0}); // evitar divisão por zero\\n        return;\\n    }\\n    urb_push(stack, (Value){.i = a / b});\\n}\\n\\nvoid URB_mod(List* stack)\\n{\\n    Int a = urb_pop(stack).i;\\n    Int b = urb_pop(stack).i;\\n    if (a == 0) {\\n        urb_push(stack, (Value){.i = 0});\\n        return;\\n    }\\n    urb_push(stack, (Value){.i = a % b});\\n}\\n\\n// bitwise stuff\\n\\nvoid URB_band(List* stack)\\n{\\n    Int a = urb_pop(stack).i;\\n    Int b = urb_pop(stack).i;\\n    urb_push(stack, (Value){.i = a & b});\\n}\\n\\nvoid URB_bor(List* stack)\\n{\\n    Int a = urb_pop(stack).i;\\n    Int b = urb_pop(stack).i;\\n    urb_push(stack, (Value){.i = a | b});\\n}\\n\\nvoid URB_bxor(List* stack)\\n{\\n    Int a = urb_pop(stack).i;\\n    Int b = urb_pop(stack).i;\\n    urb_push(stack, (Value){.i = a ^ b});\\n}\\n\\nvoid URB_bnot(List* stack)\\n{\\n    Int a = urb_pop(stack).i;\\n    urb_push(stack, (Value){.i = ~a});\\n}\\n\\nvoid URB_lshift(List* stack)\\n{\\n    Int a = urb_pop(stack).i;\\n    Int b = urb_pop(stack).i;\\n    urb_push(stack, (Value){.i = a << b});\\n}\\n\\nvoid URB_rshift(List* stack)\\n{\\n    Int a = urb_pop(stack).i;\\n    Int b = urb_pop(stack).i;\\n    urb_push(stack, (Value){.i = a >> b});\\n}\\n\\n// condition stuff\\n\\nvoid URB_gt(List* stack)\\n{\\n    Int a = urb_pop(stack).i;\\n    Int b = urb_pop(stack).i;\\n    urb_push(stack, (Value){.i = a > b});\\n}\\n\\nvoid URB_lt(List* stack)\\n{\\n    Int a = urb_pop(stack).i;\\n    Int b = urb_pop(stack).i;\\n    urb_push(stack, (Value){.i = a < b});\\n}\\n\\nvoid URB_ge(List* stack)\\n{\\n    Int a = urb_pop(stack).i;\\n    Int b = urb_pop(stack).i;\\n    urb_push(stack, (Value){.i = a >= b});\\n}\\n\\nvoid URB_le(List* stack)\\n{\\n    Int a = urb_pop(stack).i;\\n    Int b = urb_pop(stack).i;\\n    urb_push(stack, (Value){.i = a <= b});\\n}\\n\\nvoid URB_eq(List* stack)\\n{\\n    Int a = urb_pop(stack).i;\\n    Int b = urb_pop(stack).i;\\n    urb_push(stack, (Value){.i = a == b});\\n}\\n\\nvoid URB_ne(List* stack)\\n{\\n    Int a = urb_pop(stack).i;\\n    Int b = urb_pop(stack).i;\\n    urb_push(stack, (Value){.i = a != b});\\n}\\n\\nvoid URB_not(List* stack)\\n{\\n    urb_push(stack, (Value){.i = !urb_pop(stack).i});\\n}\\n#include \\\"urb.h\\\"\\n\\nvoid print(List* stack)\\n{\\n    Int value = urb_pop(stack).i;\\n    printf(\\\"%ld\\\", value);\\n}\\n\\nvoid println(List* stack)\\n{\\n    Int value = urb_pop(stack).i;\\n    printf(\\\"%ld\\\\n\\\", value);\\n}\\n\\nvoid pring(List* stack)\\n{\\n    unsigned char* str = urb_pop(stack).p;\\n    printf(\\\"%s\\\", str);\\n}\\n\\nvoid pringln(List* stack)\\n{\\n    unsigned char* str = urb_pop(stack).p;\\n    printf(\\\"%s\\\\n\\\", str);\\n}\\n\\nvoid ls(List* stack)\\n{\\n    // [index, type, \\\"name\\\"] = value;\\n    List* list = urb_pop(stack).p;\\n    for (Int i = 0; i < list->size; i++)\\n    {\\n        printf(\\\"[%ld] = %ld\\\\n\\\", i, list->data[i].i);\\n    }\\n}\\n\\n// file i/o\\nvoid load_urbin(List* stack)\\n{\\n    // all variables are misnamed because they came from another context\\n\\n    char* filename = urb_pop(stack).p;\\n    FILE* file = fopen(filename, \\\"rb\\\");\\n    if (!file) \\n    {\\n        PANIC(\\\"tried loading a file that doesnt exist.\\\\n\\\");\\n    }\\n\\n    Int code_size;\\n    if (fread(&code_size, sizeof(Int), 1, file) != 1) \\n    {\\n        PANIC(\\\"tried loading a file that is corrupted or not a valid URB binary.\\\\n\\\");\\n    }\\n\\n    Int cap = 1;\\n    while (cap < code_size) cap *= 2;\\n\\n    List* code = urb_new(cap);\\n    code->size = code_size;\\n\\n    if (fread(code->data, sizeof(Int), code->size, file) != code->size) {\\n        PANIC(\\\"tried loading a file that is corrupted or not a valid URB binary.\\\\n\\\");\\n    }\\n\\n    fclose(file);\\n    urb_push(stack, (Value){.p = code});\\n}\\n#include \\\"urb.h\\\"\\n\\nvoid URB_pack(List* stack)\\n{\\n    Int count = urb_pop(stack).i;\\n    List* new_list = urb_new(URB_DEFAULT_SIZE);\\n    for (Int i = 0; i < count; i++)\\n    {\\n        urb_push(new_list, urb_pop(stack));\\n    }\\n    urb_push(stack, (Value){.p = new_list});\\n}\\n\\nvoid URB_unpack(List* stack)\\n{\\n    List* list = urb_pop(stack).p;\\n    while(list->size > 0)\\n    {\\n        urb_push(stack, urb_pop(list));\\n    }\\n}\\n\\nvoid URB_sublist(List* stack)\\n{\\n    List* list = urb_pop(stack).p; \\n    Int offset = urb_pop(stack).i;\\n    Int count = urb_pop(stack).i;\\n    Int capacity = 1;\\n    while(count > capacity) capacity *= 2;\\n\\n    List* new_list = urb_new(capacity);\\n    new_list->size = count;\\n    memcpy(new_list->data, list->data + offset, sizeof(Int) * count);\\n    \\n    urb_push(stack, (Value){.p = new_list});\\n}\\n\\nvoid URB_push(List* stack)\\n{\\n    List* list = urb_pop(stack).p;\\n    Value value = urb_pop(stack);\\n    urb_push(list, value);\\n}\\n\\nvoid URB_pop(List* stack)\\n{\\n    List* list = urb_pop(stack).p;\\n    urb_push(stack, urb_pop(list));\\n}\\n\\nvoid URB_shift(List* stack)\\n{\\n    List* list = urb_pop(stack).p;\\n    urb_push(stack, urb_remove(list, 0));\\n}\\n\\nvoid URB_unshift(List* stack)\\n{\\n    List* list = urb_pop(stack).p;\\n    Value value = urb_pop(stack);\\n    urb_insert(list, 0, value);\\n}\\n\\nvoid URB_insert(List* stack)\\n{\\n    List* list = urb_pop(stack).p;\\n    Int index = urb_pop(stack).i;\\n    Value value = urb_pop(stack);\\n    urb_insert(list, index, value);\\n}\\n\\nvoid URB_remove(List* stack)\\n{\\n    List* list = urb_pop(stack).p;\\n    Int index = urb_pop(stack).i;\\n    urb_push(stack, urb_remove(list, index));\\n}\\n\\nvoid URB_set(List* stack)\\n{\\n    List* list = urb_pop(stack).p;\\n    Int index = urb_pop(stack).i;\\n    Value value = urb_pop(stack);\\n    list->data[index] = value;\\n}\\n\\nvoid URB_get(List* stack)\\n{\\n    List* list = urb_pop(stack).p;\\n    Int index = urb_pop(stack).i;\\n    urb_push(stack, list->data[index]);\\n}\\n\\nvoid URB_len(List* stack)\\n{\\n    List* list = urb_pop(stack).p;\\n    urb_push(stack, (Value){.i = list->size});\\n}\\n\\nvoid URB_clear(List* stack)\\n{\\n    List* list = urb_pop(stack).p;\\n    list->size = 0;\\n}\\n\\nvoid URB_peek(List* stack)\\n{\\n    List* list = urb_pop(stack).p;\\n    urb_push(stack, list->data[list->size - 1]);\\n}\\n\\nvoid URB_swap(List* stack)\\n{\\n    List* list = urb_pop(stack).p;\\n    Int index_b = urb_pop(stack).i;\\n    Int index_a = urb_pop(stack).i;\\n\\n    if (index_a < 0 || index_a >= list->size || index_b < 0 || index_b >= list->size)\\n    {\\n        PANIC(\\\"cannot swap out-of-bounds elements.\\\");\\n        return;\\n    }\\n\\n    Value tmp = list->data[index_a];\\n    list->data[index_a] = list->data[index_b];\\n    list->data[index_b] = tmp;\\n\\n    // mantém consistência: devolve a lista no topo da pilha\\n    urb_push(stack, (Value){.p = list});\\n}\\n\\nvoid URB_free(List* stack)\\n{\\n    urb_free(urb_pop(stack).p);\\n}\\n\\nvoid URB_pointer(List* stack)\\n{\\n    List* list = urb_pop(stack).p;\\n    Int index = urb_pop(stack).i;\\n    urb_push(stack, (Value){.p = list->data + index});\\n}\\n\\nvoid URB_find(List* stack)\\n{\\n    List* list = urb_pop(stack).p;\\n    Value v = urb_pop(stack);\\n    Int result = -1;\\n    for (size_t i = 0; i < list->size; i++)\\n    {\\n        if (list->data[i].u == v.u)\\n        {\\n            result = i;\\n        }\\n    }\\n    printf(\\\"result: %d\\\\n\\\", result);\\n    urb_push(stack, (Value){.i = result});\\n}\\n#include \\\"urb.h\\\"\\n\\n// interpret\\nvoid URB_memcpy(List* stack)\\n{\\n    void* dest = urb_pop(stack).p;\\n    void* origin = urb_pop(stack).p;\\n    Int len = urb_pop(stack).i;\\n    memcpy(dest, origin, len);\\n}\\n\\nvoid URB_memmove(List* stack)\\n{\\n    void* dest = urb_pop(stack).p;\\n    void* origin = urb_pop(stack).p;\\n    Int len = urb_pop(stack).i;\\n    memcpy(dest, origin, len);\\n}\\n\\nvoid URB_memfree(List* stack)\\n{\\n    free(urb_pop(stack).p);\\n}\\n\\nvoid URB_memalloc(List* stack)\\n{\\n    urb_push(stack, (Value){.p = malloc(urb_pop(stack).i)});\\n}\\n\\nvoid URB_memcalloc(List* stack)\\n{\\n    urb_push(stack, (Value){.p = calloc(urb_pop(stack).i, 1)});\\n}\\n\\nvoid URB_memset(List* stack)\\n{\\n    void* ptr = urb_pop(stack).p;\\n    uint8_t value = urb_pop(stack).i;\\n    Int len = urb_pop(stack).i;\\n    memset(ptr, value, len);\\n}\\n\\nvoid URB_memget(List* stack)\\n{\\n    uint8_t* ptr = urb_pop(stack).p;\\n    Int index = urb_pop(stack).i;\\n    urb_push(stack, (Value){.i = ptr[index]});\\n}\\n\\nvoid URB_memcmp(List* stack)\\n{\\n    void* mem1 = urb_pop(stack).p;\\n    void* mem2 = urb_pop(stack).p;\\n    Int memsize = urb_pop(stack).i;\\n    urb_push(stack, (Value){.i = memcmp(mem1, mem2, memsize)});\\n}\\n#include \\\"urb.h\\\"\\n\\n// interpret\\nvoid URB_interpret(List* stack)\\n{\\n    List* exec = urb_pop(stack).p;\\n    List* mem = urb_pop(stack).p;\\n    List* _stack = urb_pop(stack).p;\\n    urb_interpret(exec, mem, _stack);\\n}\\n\\nvoid URB_stack(List* stack)\\n{\\n    urb_push(stack, (Value){.p = stack});\\n}\\n\\nvoid URB_dup(List* stack)\\n{\\n    urb_push(stack, stack->data[stack->size - 1]);\\n}\\n\\nvoid URB_over(List* stack)\\n{\\n    Value a = urb_pop(stack);\\n    Value b = urb_pop(stack);\\n    urb_push(stack, b);\\n    urb_push(stack, a);\\n    urb_push(stack, b);\\n}\\n\\nvoid URB_rot(List* stack)\\n{\\n    Value a = urb_pop(stack);\\n    Value b = urb_pop(stack);\\n    Value c = urb_pop(stack);\\n    urb_push(stack, b);\\n    urb_push(stack, a);\\n    urb_push(stack, c);\\n}\\n\\nvoid URB_drop(List* stack)\\n{\\n    urb_pop(stack);\\n}\\n#include \\\"urb.h\\\"\\n\\n// interpret\\nvoid URB_strdup(List* stack)\\n{\\n    char* str = urb_pop(stack).p;\\n    char *dup = (char*)malloc(strlen(str) + 1);\\n    strcpy(dup, str);\\n    urb_push(stack, (Value){.p = dup});\\n}\\n\\nvoid URB_strcat(List* stack)\\n{\\n    char* str1 = urb_pop(stack).p;\\n    char* str2 = urb_pop(stack).p;\\n    Int len1 = strlen(str1);\\n    Int len2 = strlen(str2);\\n    char *dup = (char*)malloc(len1 + len2 + 1);\\n    strcpy(dup, str1);\\n    strcpy(dup + len1, str2);\\n    urb_push(stack, (Value){.p = dup});\\n}\\n\\nvoid URB_strsub(List* stack)\\n{\\n    char* str = urb_pop(stack).p;\\n    Int pos = urb_pop(stack).i;\\n    Int len = urb_pop(stack).i;\\n    char *dup = (char*)malloc(len + 1);\\n    strncpy(dup, str + pos, len);\\n    urb_push(stack, (Value){.p = dup});\\n}\\n\\nvoid URB_strtol(List* stack)\\n{\\n    char* str = urb_pop(stack).p;\\n    void* endptr = urb_pop(stack).p;\\n    Int base = urb_pop(stack).i;\\n    urb_push(stack, (Value){.i = strtol(str, endptr, base)});\\n}\\n\\nvoid URB_strstr(List* stack)\\n{\\n    char* str1 = urb_pop(stack).p;\\n    char* str2 = urb_pop(stack).p;\\n    urb_push(stack, (Value){.p = strstr(str1, str2)});\\n}\\n\\nvoid URB_strchr(List* stack)\\n{\\n    char* str = urb_pop(stack).p;\\n    char ch = urb_pop(stack).i;\\n    urb_push(stack, (Value){.p = strchr(str, ch)});\\n}\\n\\nvoid URB_strcmp(List* stack)\\n{\\n    char* str1 = urb_pop(stack).p;\\n    char* str2 = urb_pop(stack).p;\\n    urb_push(stack, (Value){.i = strcmp(str1, str2)});\\n}\\n\\nint main(int argc, char* argv[]){\\n\\nList *mem = urb_new(4);\\n\\turb_push(mem, (Value){.i = 785});\\n\\turb_push(mem, (Value){.u = (INT_MIN + OP_CODES_OFFSET + 52)});\\n\\turb_push(mem, (Value){.u = (INT_MIN + OP_CODES_OFFSET + 28)});\\n\\turb_push(mem, (Value){.u = (INT_MIN + OP_CODES_OFFSET + 20)});\\n\\n\\tList *exec = urb_new(64);\\n\\turb_push(exec, (Value){.p = test_func});\\n\\turb_push(exec, (Value){.p = URB_add});\\n\\turb_push(exec, (Value){.p = URB_sub});\\n\\turb_push(exec, (Value){.p = URB_mul});\\n\\turb_push(exec, (Value){.p = URB_div});\\n\\turb_push(exec, (Value){.p = URB_mod});\\n\\turb_push(exec, (Value){.p = URB_band});\\n\\turb_push(exec, (Value){.p = URB_bor});\\n\\turb_push(exec, (Value){.p = URB_bxor});\\n\\turb_push(exec, (Value){.p = URB_bnot});\\n\\turb_push(exec, (Value){.p = URB_lshift});\\n\\turb_push(exec, (Value){.p = URB_rshift});\\n\\turb_push(exec, (Value){.p = URB_gt});\\n\\turb_push(exec, (Value){.p = URB_lt});\\n\\turb_push(exec, (Value){.p = URB_ge});\\n\\turb_push(exec, (Value){.p = URB_le});\\n\\turb_push(exec, (Value){.p = URB_eq});\\n\\turb_push(exec, (Value){.p = URB_ne});\\n\\turb_push(exec, (Value){.p = URB_not});\\n\\turb_push(exec, (Value){.p = print});\\n\\turb_push(exec, (Value){.p = println});\\n\\turb_push(exec, (Value){.p = pring});\\n\\turb_push(exec, (Value){.p = pringln});\\n\\turb_push(exec, (Value){.p = ls});\\n\\turb_push(exec, (Value){.p = load_urbin});\\n\\turb_push(exec, (Value){.p = URB_pack});\\n\\turb_push(exec, (Value){.p = URB_unpack});\\n\\turb_push(exec, (Value){.p = URB_sublist});\\n\\turb_push(exec, (Value){.p = URB_push});\\n\\turb_push(exec, (Value){.p = URB_pop});\\n\\turb_push(exec, (Value){.p = URB_shift});\\n\\turb_push(exec, (Value){.p = URB_unshift});\\n\\turb_push(exec, (Value){.p = URB_insert});\\n\\turb_push(exec, (Value){.p = URB_remove});\\n\\turb_push(exec, (Value){.p = URB_set});\\n\\turb_push(exec, (Value){.p = URB_get});\\n\\turb_push(exec, (Value){.p = URB_len});\\n\\turb_push(exec, (Value){.p = URB_clear});\\n\\turb_push(exec, (Value){.p = URB_peek});\\n\\turb_push(exec, (Value){.p = URB_swap});\\n\\turb_push(exec, (Value){.p = URB_free});\\n\\turb_push(exec, (Value){.p = URB_pointer});\\n\\turb_push(exec, (Value){.p = URB_find});\\n\\turb_push(exec, (Value){.p = URB_memcpy});\\n\\turb_push(exec, (Value){.p = URB_memmove});\\n\\turb_push(exec, (Value){.p = URB_memfree});\\n\\turb_push(exec, (Value){.p = URB_memalloc});\\n\\turb_push(exec, (Value){.p = URB_memcalloc});\\n\\turb_push(exec, (Value){.p = URB_memset});\\n\\turb_push(exec, (Value){.p = URB_memget});\\n\\turb_push(exec, (Value){.p = URB_memcmp});\\n\\turb_push(exec, (Value){.p = URB_interpret});\\n\\turb_push(exec, (Value){.p = URB_stack});\\n\\turb_push(exec, (Value){.p = URB_dup});\\n\\turb_push(exec, (Value){.p = URB_over});\\n\\turb_push(exec, (Value){.p = URB_rot});\\n\\turb_push(exec, (Value){.p = URB_drop});\\n\\turb_push(exec, (Value){.p = URB_strdup});\\n\\turb_push(exec, (Value){.p = URB_strcat});\\n\\turb_push(exec, (Value){.p = URB_strsub});\\n\\turb_push(exec, (Value){.p = URB_strtol});\\n\\turb_push(exec, (Value){.p = URB_strstr});\\n\\turb_push(exec, (Value){.p = URB_strchr});\\n\\turb_push(exec, (Value){.p = URB_strcmp});\\n\\turb_interpret(exec, mem, NULL);\\n\\turb_free(exec);\\n}\\n\\n\",\"output\":\"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n// interpret\\n// URB_interpret\\n#define OP_URB_interpret (INT_MIN + OP_CODES_OFFSET + 0)\\nvoid URB_interpret(List* stack) {\\n    List* exec = urb_pop(stack).p;\\n    List* mem = urb_pop(stack).p;\\n    List* _stack = urb_pop(stack).p;\\n    urb_interpret(exec, mem, _stack);\\n}\\n\\n\\n// URB_stack\\n#define OP_URB_stack (INT_MIN + OP_CODES_OFFSET + 1)\\nvoid URB_stack(List* stack) {\\n    urb_push(stack, (Value){.p = stack});\\n}\\n\\n\\n// URB_dup\\n#define OP_URB_dup (INT_MIN + OP_CODES_OFFSET + 2)\\nvoid URB_dup(List* stack) {\\n    urb_push(stack, stack->data[stack->size - 1]);\\n}\\n\\n\\n// URB_over\\n#define OP_URB_over (INT_MIN + OP_CODES_OFFSET + 3)\\nvoid URB_over(List* stack) {\\n    Value a = urb_pop(stack);\\n    Value b = urb_pop(stack);\\n    urb_push(stack, b);\\n    urb_push(stack, a);\\n    urb_push(stack, b);\\n}\\n\\n\\n// URB_rot\\n#define OP_URB_rot (INT_MIN + OP_CODES_OFFSET + 4)\\nvoid URB_rot(List* stack) {\\n    Value a = urb_pop(stack);\\n    Value b = urb_pop(stack);\\n    Value c = urb_pop(stack);\\n    urb_push(stack, b);\\n    urb_push(stack, a);\\n    urb_push(stack, c);\\n}\\n\\n\\n// URB_drop\\n#define OP_URB_drop (INT_MIN + OP_CODES_OFFSET + 5)\\nvoid URB_drop(List* stack) {\\n    urb_pop(stack);\\n}\\n\\n\\n\\n#define INIT_URB(context)\\\\\\nurb_push(context, (Value){.p = URB_interpret});\\\\\\nurb_push(context, (Value){.p = URB_stack});\\\\\\nurb_push(context, (Value){.p = URB_dup});\\\\\\nurb_push(context, (Value){.p = URB_over});\\\\\\nurb_push(context, (Value){.p = URB_rot});\\\\\\nurb_push(context, (Value){.p = URB_drop});\\\\\\n0;\",\"createdAt\":\"12/9/2025, 10:48:02 AM\"},\"1765304603121\":{\"id\":\"1765304603121\",\"name\":\"optional\",\"input\":\"$pattern {aaaaa $x? world} {<$x>}\\naaaaa  world\",\"output\":\"\\no match é eval(return papagaio.match)\",\"createdAt\":\"12/9/2025, 3:23:23 PM\"},\"1765307172823\":{\"id\":\"1765307172823\",\"name\":\"multichar\",\"input\":\"// custom delimtiers test\\n@pattern ab greet @name bc ab Hello, @name! bc\\n\\ngreet World\\ngreet JavaScript\",\"output\":\"\\n\\n\\n\\n\\nHello, World!\\nHello, JavaScript!\",\"createdAt\":\"12/9/2025, 4:06:12 PM\"},\"1765411870105\":{\"id\":\"1765411870105\",\"name\":\"regex\",\"input\":\"// apaga todos os comentarios\\n$pattern {// $comment $regex newline{[^\\\\n]*}} {}\\n\\n// Capturar apenas números\\n$pattern {numero: $regex num{[0-9]+}} {O número é $num}\\nnumero: 42\\n// Resultado: O número é 42\\n\\n// Capturar email\\n$pattern {email: $regex mail{[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\\\.[a-zA-Z]{2,}}} {Email: $mail}\\nemail: teste@exemplo.com\\n// Resultado: Email: teste@exemplo.com\\n\\n// Capturar palavras específicas\\n$pattern {status: $regex estado{(ativo|inativo|pendente)}} {Status: $estado}\\nstatus: ativo\\n// Resultado: Status: ativo\\n\\n// Capturar hexadecimal\\n$pattern {cor: $regex hex{#[0-9A-Fa-f]{6}}} {Cor capturada: $hex}\\ncor: #FF5733\\n// Resultado: Cor capturada: #FF5733\",\"createdAt\":\"12/10/2025, 9:11:10 PM\"},\"1765468252045\":{\"id\":\"1765468252045\",\"name\":\"wasm\",\"input\":\"// generic ts-like to wasm compiler\\n\\n// util patterns\\n$pattern {// $comment $regex newline{[^\\\\n]*}} {}\\n$pattern {$regex spaces{\\\\s\\\\s}}{ }\\n\\n$eval{\\n    papagaio.exit = function()\\n    {\\n        papagaio.content = \\\"(module\\\\n\\\" + papagaio.content + \\\"\\\\n)\\\";\\n        papagaio.exit = null;\\n    };\\n    return \\\"\\\"\\n}\\n\\n$pattern {export function $name $(...params...) :$rets $block content{}{}} {\\n    $pattern {parametrize}\\n    {\\n        $eval {\\n            let str = \\\"$params\\\".replace(\\\"(\\\", \\\"\\\").replace(\\\")\\\", \\\"\\\");\\n            let params = str.split(\\\",\\\").map(p => p.trim()).filter(p => p);\\n            let new_stuff = \\\"\\\";\\n            for (const param of params) {\\n                if (!param.includes(\\\":\\\")) continue; // Pula se não tem ':'\\n                const [name, type] = param.split(\\\":\\\");\\n                if (name && type) { // Verifica se ambos existem\\n                    new_stuff += ` (param $${name.trim()} ${type.trim()}) `;\\n                }\\n            }\\n            return new_stuff;\\n        }\\n    }\\n\\n    (func (export \\\"$name\\\") parametrize (result $rets)\\n        $content\\n    )\\n}\\n\\n$pattern {function $name $block params{(}{)}:$rets $block content{}{}} {\\n    $pattern {parametrize}\\n    {\\n        $eval {\\n            let str = \\\"$params\\\".replace(\\\"(\\\", \\\"\\\").replace(\\\")\\\", \\\"\\\");\\n            let params = str.split(\\\",\\\").map(p => p.trim()).filter(p => p);\\n            let new_stuff = \\\"\\\";\\n            for (const param of params) {\\n                if (!param.includes(\\\":\\\")) continue; // Pula se não tem ':'\\n                const [name, type] = param.split(\\\":\\\");\\n                if (name && type) { // Verifica se ambos existem\\n                    new_stuff += ` (param $${name.trim()} ${type.trim()}) `;\\n                }\\n            }\\n            return new_stuff;\\n        }\\n    }\\n\\n    (func $$name parametrize (result $rets)\\n        $content\\n    )\\n}\\n\\nfunction name(a:i32, b:i32):i64 i64\\n{\\n    contentnans\\n}\\n\\nexport function funcao_exportada(a:f32, b:f32, c:f32):i64 i64 i64 i64\\n{\\n    fução expoortada1\\n}\\n\",\"createdAt\":\"12/11/2025, 12:50:52 PM\"},\"1765499397266\":{\"id\":\"1765499397266\",\"name\":\"scopes\",\"input\":\"$pattern {a} {\\n   $pattern{b}{c}\\n   $pattern{d}{\\n      bbbbb\\n}\\nd\\n}\\n\\na\",\"createdAt\":\"12/11/2025, 9:29:57 PM\"},\"1765753638228\":{\"id\":\"1765753638228\",\"name\":\"teste\",\"input\":\"\\n$pattern {aa} {b}\\n$pattern {aa aa b} {c}\\nb b b\\n\\n$pattern {$open...$name...$close} {$block $name{$open}{$close}}\\n\\n$pattern {(...name...)} {stuff: $name}\\n(aoba)\",\"createdAt\":\"12/14/2025, 8:07:18 PM\"},\"1765836421541\":{\"id\":\"1765836421541\",\"name\":\"rap teste\",\"input\":\"$eval{papagaio.counter = 0;return \\\"\\\"}\\n\\n$pattern {if $block condition{(}{)} $block iftrue{}{} else $block iffalse{}{}} \\n{\\n\\n    goif($condition, if_counter_true)\\n    goto(if_counter_false)\\n    private if_counter_true {\\n        $iftrue\\n    }\\n    private if_counter_false {\\n        $iffalse\\n    }\\n}\\n\\n\\n\\n\\n$pattern {counter_increment} {$eval{papagaio.counter++;return \\\"\\\"}}\\n$pattern {counter} {$eval{return papagaio.counter}}\\n\\nif (a)\\n{\\n  b\\n}\\nelse\\n{\\n  c\\n}\",\"createdAt\":\"12/15/2025, 7:07:01 PM\"}}",
  "papagaio_current_sketch": "1765411870105",
  "papagaio_config": "{\"sigil\":\"$\",\"open\":\"{\",\"close\":\"}\",\"local\":\"local\",\"global\":\"global\",\"eval\":\"eval\",\"block\":\"block\",\"regex\":\"regex\"}"
}